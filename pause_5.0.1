#! /usr/bin/bash

# This script allow for the interruption of the current process until either the
# timer reaches 00 or the user presses any key. If no timer is used the process
# will be stopped indefinitely until the user manually continues the process with
# the press of any key except shift. Using the timer (in seconds only) continues 
# the current process without user intervention.

declare DEFAULT_PROMPT RETURN_TEXT SCRIPT VERSION COPYRIGHT DESCRIPTION arg OPTION LOOP_COUNT text_prompt return_prompt
declare -i TIMER QUIET LOOP_COUNT
unset TIMER QUIET DEFAULT_PROMPT RETURN_TEXT SCRIPT VERSION COPYRIGHT DESCRIPTION arg OPTION LOOP_COUNT text_prompt return_prompt
DEFAULT_PROMPT="Press any key to continue..."
SCRIPT="${0##*/}"
VERSION='5.0.1'
# AUTHOR='CSPhelps'
COPYRIGHT="MIT License. Software is intended as free use and is offered 
'as is' with no implied guarantees or copyrights."
DESCRIPTION="A simple script that interrupts the current process. 

Optional custom prompt message and countdown timer. 

Command will interrupt process indefinitely until 
  user presses any key or optional timer reaches 00. 
"
for arg in "$@"; do
  shift
  case "$arg" in
    '--quiet'    ) set -- "$@" '-q'   ;;
    '--timer'    ) set -- "$@" '-t'   ;;
    '--prompt'   ) set -- "$@" '-p'   ;;
    '--response' ) set -- "$@" '-r'   ;;
    '--help'     ) set -- "$@" '-h'   ;;
    *            ) set -- "$@" "$arg" ;;
  esac
done

while getopts "qt:p:r:h" OPTION; do
  case "$OPTION" in
    t)  TIMER="${OPTARG//^[0-9]/}"
        if [[ -z $TIMER ]] ; then echo "Timer not set" ; exit 2 ; fi
        ;;
    p)  DEFAULT_PROMPT="${OPTARG}" ;
        ;;
    r)  RETURN_TEXT="${OPTARG}" ;      
    ;;
    h)  
echo "${SCRIPT} v.${VERSION}

${COPYRIGHT}

${DESCRIPTION}

Default prompt: ${DEFAULT_PROMPT}

Usage:
${SCRIPT} [-p|--prompt ] [-t|--timer ] [-r|--response ] [-h|--help] [-q|--quiet] 

    -p, --prompt    [ input required (string must be in quotes) ]
    -t, --timer     [ number of seconds ]
    -r, --response  [ requires text (string must be in quotes) ]
    -h, --help      [ this information ]
    -q, --quiet     [ quiets text, requires timer be set. ]

Examples:
Input:  $ ${SCRIPT}
Output: $ ${DEFAULT_PROMPT}

Input:  $ ${SCRIPT} -t <seconds>
Output: $ [timer] ${DEFAULT_PROMPT}

Input:  $ ${SCRIPT} --prompt \"Optional Prompt\" --response \"Your response\"
Output: $ Optional Prompt
        $ Your Response

Input:  $ ${SCRIPT} -p \"Optional Prompt\" -r \"[ Your response ]\" --timer <seconds>
Output: $ [timer] Optional Prompt
        $ [ Your Response ]

[ seconds are converted to 00h:00m:00s style format ]
"  
        exit 0 
        ;;
    q ) QUIET=0
    ;;
    ?)  
echo "${SCRIPT} v.${VERSION}
${COPYRIGHT}
${DESCRIPTION}
Usage:
${SCRIPT} [-p|--prompt ] [-t|--timer ] [-r|--response ] [-h|--help] [-q|--quiet] 

    -p, --prompt    [ input required (string must be in quotes) ]
    -t, --timer     [ number of seconds ]
    -r, --response  [ requires text (string must be in quotes) ]
    -h, --help      [ this information ]
    -q, --quiet     [ quiet text, requires timer be set. ]
"
        exit 1
        ;;
  esac
done

shift "$(( OPTIND - 1 ))"

quiet(){ 
local LOOP_COUNT="${1}"
while (( LOOP_COUNT > 0 )) ; do
    printf '\e[K'
    (( LOOP_COUNT = LOOP_COUNT - 1 ))
    read -rsn1 -t1 &>/dev/null 2>&1
    errorcode=$?
    [[ $errorcode -eq 0 ]] && LOOP_COUNT=0
done
}

# timer interrupt
interrupt0(){
    unset LOOP_COUNT text_prompt return_prompt 
    unset num sec min hour day
    local LOOP_COUNT="${1}"
    local text_prompt="${2}"
    local return_prompt="${3}"
    declare -i num sec min hour day
    printf '\e[?25l'
    while (( LOOP_COUNT > 0 )) ; do
        printf '\e[K'
        printf '[%s]' "$( 
        num="${LOOP_COUNT}"
        if((num>59));then
            ((sec=num%60))
            ((num=num/60))
            if((num>59));then
                ((min=num%60))
                ((num=num/60))
                if((num>23));then
                    ((hour=num%24))
                    ((day=num/24))
                else
                    ((hour=num))
                fi
            else
                ((min=num))
            fi
        else
            ((sec=num))
        fi
        if (( day > 0 )) ; then printf '%02g:' "${day}" ; fi
        if (( day > 0 )) || (( hour > 0 )) ; then printf '%02g:' "${hour}" ; fi
        if (( day > 0 )) || (( hour > 0 )) || (( min > 0 )) ; then printf '%02g:' "${min}" ; fi
        if (( day > 0 )) || (( hour > 0 )) || (( min > 0 )) || (( sec >= 0 )) ; then printf '%02g' "${sec}" ; fi
)" ; 
        printf ' %s\r' "${text_prompt}"
#        printf "[%02d] ${text_prompt[*]} \r" "${LOOP_COUNT}" >&2
        (( LOOP_COUNT = LOOP_COUNT - 1 ))
        read -rsn1 -t1 &>/dev/null 2>&1
        errorcode=$?
        [[ $errorcode -eq 0 ]] && LOOP_COUNT=0
    done 

    printf '\e[?25h'
    
    if [[ -n ${return_prompt} ]] ; 
    then 
        printf '\n%s\r\n' "${return_prompt}" ; 
    else 
        printf '\n' ; 
    fi

    return 0
} ;

# pause interrupt
interrupt1(){ 
    local text_prompt="${1}"
    local return_prompt="${2}"
    printf '%s\n' "$(read -rsn 1 -p "${text_prompt[*]}" )"
    if [[ -n ${return_prompt} ]] ; 
        then printf '\n%s\r\n' "${return_prompt}" ; 
    fi
    return 0 
} ;

if  [[ -n ${QUIET} ]] && [[ -n ${TIMER} ]] ; 
    then quiet "${TIMER}" ; 
fi

if [[ -z ${QUIET} ]] && [[ -n ${TIMER} ]]; 
    then 
        interrupt0 "${TIMER}" "${DEFAULT_PROMPT}" "${RETURN_TEXT}" ; 
        exit $? ; 
fi

if [[ -z ${QUIET} ]] && [[ -z ${TIMER} ]]; 
    then interrupt1 "${DEFAULT_PROMPT}" "${RETURN_TEXT}" ; 
    exit $? ; 
fi

if [[ -n ${QUIET} ]] && [[ -z ${TIMER} ]]; 
    then echo "Timer must be set" ; 
fi
